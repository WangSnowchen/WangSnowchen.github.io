{"posts":[{"title":"通过CollectScenes、FilterResults和NameSwitch在已有的层次结构中填充已有的模型","content":"首先，简单介绍一下这三个节点的创建方式以及功能 CollectScenes可以直接在菜单中创建出来 通过将多个输入场景数据捆绑在一起来构建场景，每个场景都有自己的根位置。它不像组节点那样使用多个输入接口，而是使用单个输入口，并提供一个context变量，以便在每个根位置下生成不同的层次结构。这对于构建动态场景尤其有效，因为在构建节点图之前，对于输入的场景数量是未知的。 简单做个示例： 使用CollectScenes之后 FilterResults是一个隐藏节点，你可以按下↓进入节点set内部来获取，它可以帮你查找你在PathFilter中指定的内容并且给你返回一个字符串列表 NameSwitch可以从菜单创建 在多个输入连接之间切换，通过所选的输入到输出。每个输入端都有一个 &quot;名称 &quot;和一个值，切换是通过比较名称和 selector 的值来完成的 这里的selector可以使用context变量来替换 简短的讲解之后回到我们这个案例中来 首先通过group节点构建出一个简单的层次结构 然后通过FilterResults求出整个root根的结构 可以通过python Editor来验证一下 root['FilterResults']['outStrings'].getValue() ##返回数值 /assetA.000 /assetA.001 /assetB.000 ","link":"https://wangsnowchen.github.io/post/tong-guo-collectscenes-he-filterresults-zai-yi-you-de-ceng-ci-jie-gou-zhong-tian-chong-yi-you-de-mo-xing/"},{"title":"使用OSL节点实现Houdini中的Clip节点功能","content":" 这里使用OSLObject节点对点属性的向量P进行操作 首先获取全局的P属性，将三维向量转换成三个对应的浮点数XYZ 然后对Y轴浮点数做一次判断 让Y轴上数值大于0的点替换成自定义的浮点数字 再将计算完毕的Y轴浮点数与其他两个轴合并成向量替换P属性 ","link":"https://wangsnowchen.github.io/post/shi-yong-osl-jie-dian-shi-xian-houdini-zhong-de-clip-jie-dian-gong-neng/"},{"title":"在Gaffer中实现Maya的CenterPivot功能","content":"核心节点是BoundQuery location这里的${scene:path}是内置的context变量，会自动识别层次结构中的最后一层 一般情况下求取的数值我们会以local space为主，如果有特殊需求，可以切换成世界坐标 通过拖拽将${scene:path}求出的BBox的center中心数值和Transform节点上pivot关联 即可将错误的轴心回归到模型的BBox中心 ","link":"https://wangsnowchen.github.io/post/zai-gaffer-zhong-shi-xian-maya-de-centerpivot-gong-neng/"},{"title":"为不同的Primitive上创建不同的customString属性","content":"code解析 首先通过 getattribute(&quot;shading:index&quot;, index) 获取了物体点的index数值并将其赋给了变量index（类似Houdini的ptnum） 然后定义了一个空字符串 string_out = &quot;&quot; 这里在对int_list定义时，使用python脚本进行预处理。将你输入的点求出一个总数，方便之后循环中做判断 indices = parent[&quot;OSLCode2&quot;][&quot;parameters&quot;][&quot;int_list&quot;] parent[&quot;OSLCode2&quot;][&quot;parameters&quot;][&quot;array_length&quot;] = len(indices.split(&quot;,&quot;)) 之后对int_list进行了判断，如果int_list不为空，就执行下面的逻辑。 string int_array[50]; split( int_list, int_array, &quot;,&quot; ); int start_index, end_index; start_index = stoi(int_array[0]); for (int n=start_index; n&lt;array_length; n++){ string cur_index = int_array[n]; if (stoi(cur_index) == index){ string_out = test_string; } } int_list是一个字符串，通过逗号分隔的整数列表。 接着定义了一个名为int_array的字符串数组，长度为50。 使用split函数将int_list按逗号分隔并存储到int_array中。接下来定义了start_index、end_index以及n等变量。 通过循环遍历int_array中的整数，并将其转换为索引值，然后与index进行比较。如果找到匹配的索引值，就将test_string赋给string_out 这样，当你在int_list填写对应的primitive Inspector 序号数值的时候，就可以为其赋上test_string的数值 ","link":"https://wangsnowchen.github.io/post/wei-bu-tong-de-primitive-shang-chuang-jian-bu-tong-de-customstring-shu-xing/"},{"title":"Use Gaffer OSL to create dynamic model noise effects with customizable orientation","content":"Use Gaffer OSL to create dynamic model noise effects with customizable orientation. The inspiration came when I was using VOP to connect nodes in houdini and realized that there are nodes similar to AA noise in the OSL section in Gaffer, 'PointNoise'. So I made the whole noise move with time by doing a noise process on the X and Z vectors of the P attribute and replacing the Y vector with a Time float in Global. Then control the area where the noise is generated by doing a Remap on the Y vector on the P attribute alone. This is then added to the default P property to get the effect we want. ","link":"https://wangsnowchen.github.io/post/use-gaffer-osl-to-create-dynamic-model-noise-effects-with-customizable-orientation/"}]}